//
//  LockDemoHomeViewController.h
//  Demo
//
//  Created by 朱超鹏 on 2018/5/24.
//  Copyright © 2018年 zcp. All rights reserved.
//

#import <ZCPKit/ZCPKit.h>

@interface LockDemoHomeViewController : ZCPBaseViewController

@end

/*
 
 时间片轮转调度
    时间片轮转法（Round-Robin，RR）主要用于分时系统中的进程调度。为了实现轮转调度，系统把所有就绪进程按先入先出的原则排成一个队列。新来的进程加到就绪队列末尾。每当执行进程调度时，进程调度程序总是选出就绪队列的队首进程，让它在CPU上运行一个时间片的时间。时间片是一个小的时间单位，通常为10~100ms数量级。当进程用完分给它的时间片后，系统的计时器发出时钟中断，调度程序便停止该进程的运行，把它放入就绪队列的末尾；然后，把CPU分给就绪队列的队首进程，同样也让它运行一个时间片，如此往复。
    既然是片段执行，程序员就必须理解，在自己的程序运行时不是独一无二的，我们看似很顺畅的工作，其实是由一个个的执行片段构成的，我们眼中相邻的两条语句甚至同一个语句中两个不同的运算符之间，都有可能插入其他线程或进程的动作。
 
 生产者-消费者模式
 
    生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。
 
 */

/*
 
 自旋锁
    1.在忙等时，线程不会主动让出时间片。如果任务执行时间较长，如文件读写，这种忙等没有必要且白白浪费了CPU的时间。
    2.存在优先级反转问题。主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。
    3.和 NSLock 不同的是 NSLock 请求加锁失败的话，会先轮询，但一秒过后便会使线程进入 waiting 状态，等待唤醒。而 OSSpinLock 会一直轮询，等待时会消耗大量 CPU 资源，不适用于较长时间的任务。
 
 信号量
    1.在等待时，线程会进入睡眠状态，主动让出时间片。
    2.主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。
 
 互斥锁
    1.机制同信号量，但是可以有多种类型，所以性能比信号量略低一些。
    2.可以有多种类型PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE。
    3.假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。如某个函数申请了锁，在临界区内又递归调用了自己。pthread_mutex 支持递归锁，允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。
 
 
 PTHREAD_MUTEX_NORMAL 缺省类型，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后先进先出原则获得锁。
 PTHREAD_MUTEX_ERRORCHECK 检错锁，如果同一个线程请求同一个锁，则返回 EDEADLK，否则与普通锁类型动作相同。这样就保证当不允许多次加锁时不会出现嵌套情况下的死锁。
 PTHREAD_MUTEX_RECURSIVE 递归锁，允许同一个线程对同一个锁成功获得多次，并通过多次 unlock 解锁。
 PTHREAD_MUTEX_DEFAULT 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争，没有等待队列。
 
 NSLock
    1.内部封装了一个PTHREAD_MUTEX_ERRORCHECK类型的互斥锁，以损失一定性能换来错误提示
    2.NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。
 
 NSCondition
    1.封装了一个互斥锁和条件变量
    NSConditionLock 还可以实现任务之间的依赖。
    只有 condition 参数与初始化时候的 condition 相等，lock 才能正确进行加锁操作。而 unlockWithCondition: 并不是当 Condition 符合条件时才解锁，而是解锁之后，修改 Condition 的值。
 
 NSRecursiveLock
    1.内部封装了一个PTHREAD_MUTEX_RECURSIVE类型的互斥锁
    NSRecursiveLock 可以在一个线程中重复加锁
 
 NSConditionLock
    1.借助NSCondition实现
 
 */
