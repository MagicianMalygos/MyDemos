//
//  LockDemoHomeViewController.h
//  Demo
//
//  Created by 朱超鹏 on 2018/5/24.
//  Copyright © 2018年 zcp. All rights reserved.
//

#import <ZCPKit/ZCPKit.h>

@interface LockDemoHomeViewController : ZCPViewController

@end

/*
 
 时间片轮转调度
    时间片轮转法（Round-Robin，RR）主要用于分时系统中的进程调度。为了实现轮转调度，系统把所有就绪进程按先入先出的原则排成一个队列。新来的进程加到就绪队列末尾。每当执行进程调度时，进程调度程序总是选出就绪队列的队首进程，让它在CPU上运行一个时间片的时间。时间片是一个小的时间单位，通常为10~100ms数量级。当进程用完分给它的时间片后，系统的计时器发出时钟中断，调度程序便停止该进程的运行，把它放入就绪队列的末尾；然后，把CPU分给就绪队列的队首进程，同样也让它运行一个时间片，如此往复。
    既然是片段执行，程序员就必须理解，在自己的程序运行时不是独一无二的，我们看似很顺畅的工作，其实是由一个个的执行片段构成的，我们眼中相邻的两条语句甚至同一个语句中两个不同的运算符之间，都有可能插入其他线程或进程的动作。
 
 生产者-消费者模式
 
    生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。
 
 */

/*
 
 自旋锁
    1.在忙等时，线程不会主动让出时间片。如果任务执行时间较长，如文件读写，这种忙等没有必要且白白浪费了CPU的时间。
    2.存在优先级反转问题。主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。
 
 信号量
    1.在等待时，线程会进入睡眠状态，主动让出时间片。
    2.主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。
 
 互斥锁
    1.机制同信号量，但是可以有多种类型，所以性能比信号量略低一些。
    2.可以有多种类型PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE。
    3.假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。如某个函数申请了锁，在临界区内又递归调用了自己。pthread_mutex 支持递归锁，允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。
 
 NSLock
    1.内部封装了一个PTHREAD_MUTEX_ERRORCHECK类型的互斥锁，以损失一定性能换来错误提示
    2.NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。
 
 NSCondition
    1.封装了一个互斥锁和条件变量
 
 NSRecursiveLock
    1.内部封装了一个PTHREAD_MUTEX_RECURSIVE类型的互斥锁
 
 NSConditionLock
    1.借助NSCondition实现
 
 */
